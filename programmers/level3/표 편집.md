import heapq
def solution(n, k, cmds):
    answer = ''
    def inverse(num):
        return -num
    max_heap = list(map(inverse,range(k)))
    min_heap = list(range(k,n))
    deleted = ['O' for _ in range(n)]
    deleted_stack = []
    
    heapq.heapify(max_heap)
    heapq.heapify(min_heap)
    # 그냥 일반 list등으로 해결할 수 없는 이유는 원소를 넣고 빼는 과정이 반복되면서 시간 초과가 발생하기 때문
    # heap 구조를 활용하여 이 문제를 해결하였다.
    
    
    # index와 상관 없이 값을 관리할 수 있음
    # 
    for cmd in cmds:
        command = cmd.split()
        
        if len(command)>1:
            num = command[1]
            command = command[0]
            num = int(num)
            
            if command == 'D':
                for _ in range(num):
                    heapq.heappush(max_heap,-heapq.heappop(min_heap))
            else:
                for _ in range(num):
                    heapq.heappush(min_heap,-heapq.heappop(max_heap))
        else:
            command = command[0]
            if command == 'C':
                delete_num = heapq.heappop(min_heap)
                deleted_stack.append(delete_num)
                deleted[delete_num] = 'X'
                if len(min_heap) == 0:
                    heapq.heappush(min_heap,-heapq.heappop(max_heap))
            else:
                restore_num = deleted_stack.pop()
                deleted[restore_num] = 'O'
                
                if min_heap[0] > restore_num: # min_heap[0]이 가리키는 것은 현재 가리키고 있는 행임
                    # max min heap을 이용해서 행이 제거된 표를 관리하는 것이 아주 놀라웠다
                    # d와 u로 이동하는 과정에서 heap간 원소 이동을 통해서 문제를 해결 할 수 있음
                    
                    heapq.heappush(max_heap,-restore_num)
                else:
                    heapq.heappush(min_heap,restore_num)
                    
        
    answer = ''.join(deleted)
    return answer
