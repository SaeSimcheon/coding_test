# 첫번째 시도 
# 아라토스테네스 체를 사용할 것임
# 2부터 수를 증가시켜 배수를 제외함.
# checklist에서 전부 0으로 리셋해둔 다음 1로 바꿈으로써 제외시킴

def solution(n):
    
    answer = 0
    check =  [1]*2+[0]*(n-1)
    
    for i in range(2,n//2+1):
        for j in range(i,n+1,i):
            if check[j] == 0 and i !=j:
                check[j] = 1
    
    return check.count(0)
    
# 통과는 했는데 큰일 날뻔함
'''
테스트 1 〉	통과 (0.00ms, 10.2MB)
테스트 2 〉	통과 (0.05ms, 10.3MB)
테스트 3 〉	통과 (0.33ms, 10.2MB)
테스트 4 〉	통과 (0.72ms, 10.3MB)
테스트 5 〉	통과 (0.24ms, 10.3MB)
테스트 6 〉	통과 (4.51ms, 10.4MB)
테스트 7 〉	통과 (1.10ms, 10.2MB)
테스트 8 〉	통과 (3.79ms, 10.3MB)
테스트 9 〉	통과 (5.53ms, 10.3MB)
테스트 10 〉	통과 (233.44ms, 14.2MB)
테스트 11 〉	통과 (767.65ms, 23.5MB)
테스트 12 〉	통과 (263.49ms, 14.8MB)
효율성  테스트
테스트 1 〉	통과 (750.42ms, 24.3MB)
테스트 2 〉	통과 (777.27ms, 23.6MB)
테스트 3 〉	통과 (805.84ms, 24.3MB)
테스트 4 〉	통과 (785.96ms, 24MB)
'''

# 다른 사람들은 어떻게 풀었을까 ?

def solution(n):
    num=set(range(2,n+1)) # range를 통해서 집합을 만듦

    for i in range(2,n+1): # 2부터 n+1까지 탐색하는데
        if i in num: # 만약 예를들어 i가 2이면 num안에 있으므로
            num-=set(range(2*i,n+1,i)) # i*2 즉, 4부터 n+1까지 i씩 증가 -> 즉, 4 6 8 ... 2를 제외한 2의 배수를 set으로 만들어서
            # 집합의 차를 구하면 됨.
    return len(num)


'''
좋다 안 좋다 해도 내가 짠 것보다는 나은듯
테스트 1 〉	통과 (0.00ms, 10.3MB)
테스트 2 〉	통과 (0.04ms, 10.3MB)
테스트 3 〉	통과 (0.14ms, 10.3MB)
테스트 4 〉	통과 (0.22ms, 10.3MB)
테스트 5 〉	통과 (0.15ms, 10.1MB)
테스트 6 〉	통과 (2.16ms, 11.1MB)
테스트 7 〉	통과 (0.59ms, 10.4MB)
테스트 8 〉	통과 (1.64ms, 11MB)
테스트 9 〉	통과 (2.55ms, 11MB)
테스트 10 〉	통과 (70.44ms, 45.6MB)
테스트 11 〉	통과 (335.92ms, 113MB)
테스트 12 〉	통과 (97.23ms, 47.3MB)
효율성  테스트
테스트 1 〉	통과 (337.02ms, 116MB)
테스트 2 〉	통과 (317.02ms, 115MB)
테스트 3 〉	통과 (338.22ms, 116MB)
테스트 4 〉	통과 (291.50ms, 115MB)
'''


# 아래가 내 옛날 풀이인데 위보다 더 효율적임
# 자기자신을 answer로 count하고 자기자신을 포함해서 지워나가는 방식을 사용했음.
# ch[i]가 0인 경우에 대해서만 따지기 때문에 효율적
# 내가짠 코드는 그냥 전부 다 따져줬기 때문에 훨씬 비효율적임

def solution(n):
    ch = [0]*(n+1)
    answer = 0

    for i in range(2,n+1):
        if ch[i] == 0:
            answer +=1
            for k in range(i,n+1,i):
                ch[k] = 1



    return answer
