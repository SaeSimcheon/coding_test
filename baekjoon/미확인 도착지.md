```python
import sys
import heapq

from numpy import squeeze

sys.stdin = open('input.txt','r')


T=int(sys.stdin.readline())


from collections import defaultdict



def detective():
    n,m,t = map(int,sys.stdin.readline().split())
    s,g,h = map(int,sys.stdin.readline().split())

    # s -> 출발지
    # 교차로 g h

    # 다익스트라를 우선적으로 사용
    graph = defaultdict(list)
    weight = 0
    for _ in range(m):
        S,D,W = map(int,sys.stdin.readline().split())
        graph[S].append((D,W))
        graph[D].append((S,W))
        if (S == h and D == g) or (S == g and D == h):
            weight = W


    
    def SP(S,seq):

        def df():
            return float('inf')
        cost = defaultdict(df)


        Q = [(0,S)]

        while Q :
            this_cost,node = heapq.heappop(Q)

            if node not in cost :
                cost[node] = this_cost
                
                for ne in graph[node]:
                    d,w = ne
                    alt = this_cost + w
                    heapq.heappush(Q,(alt,d))

        return list(map(lambda x : cost[x],seq))
    
    a = SP(s,[g,h])
    

    candidate = []

    for _ in range(t):
        can=int(sys.stdin.readline())
        candidate.append(can)
    comp = SP(s,candidate)

    from_g=SP(g,candidate)
    from_h=SP(h,candidate)

    if s != g and s != h:
        g_first = list(map(lambda x : x + a[0] + weight,from_h))
        h_first = list(map(lambda x : x + a[1] + weight,from_g))
        seq = [min(i,j) for i,j in zip(g_first,h_first)]
    elif s != g and s == h:
        h_first = list(map(lambda x : x + weight ,from_g))
        seq = h_first
    elif s == g and s != h:
        g_first = list(map(lambda x : x + weight,from_h))
        seq = g_first

    
    

    answer =[]
    for index,(i,j) in enumerate(zip(comp,seq)):
        if i == j :
            answer.append(str(candidate[index]))
    answer.sort()
    
    for i in answer:
        print(i,end = ' ')
    
    
for _ in range(T):
    detective()

```
