
# 처음에 규칙을 찾으려고 대략 10개 정도 해봤는데 뚜렷하게 규칙이 안 보였었음.
# 그러다가 2와 3 으로 나누어 떨어지는 수와 관련이 있고, 몇몇은 바로 앞의 항과 관련이 있다는 것을 깨달음.
# 만약 2 와 3으로 전부 나누어 지는 경우를 따로 고려하여 조건문을 만들고
# F[i-1] +1 을 항상 함께 고려하도록 짬

n = int(input())

F = [0,0]


for i in range(2,n+1):
    if i % 2 == 0 and i % 3 == 0:
        F.append(min(F[i //2 ],F[i //3 ],F[i-1])+1)
    elif i %3 == 0 :
        F.append(min(F[i //3 ],F[i-1])+1)
    elif i %2 == 0 :
        F.append(min(F[i //2 ],F[i-1])+1)
    else:
        F.append(F[i-1]+1)

print(F[n])



'''
	1463	1로 만들기	맞았습니다!!	39112	608	Python 3	315	
  
  굉장히 느린 편
'''


# 다른 사람은 어떻게 풀었을까 ?

s={1:0,2:1} # 일단 딕셔너리 이용했음.
# 애초에 순서가 중요한 것도 아니기 때문에 나처럼 list를 고집해서 느린 append를 사용할 필요도 없었음.

def f(n):
 if n in s:return s[n] # n이 s에 키로 존재하면 return s[n]을 함
 m=1+min(f(n//2)+n%2,f(n//3)+n%3) # 재귀문을 사용했음.
  # 나머지만큼 더해주는 규칙으로 쓸 수 있구나
 s[n]=m
 return m
print(f(int(input())))


