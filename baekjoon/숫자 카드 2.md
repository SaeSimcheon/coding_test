## 0516
- A -> 중복 정수 존재 -> 미리 각 숫자의 개수를 파악해서 딕셔너리에 넣고 key 값을 통해서 이진탐색 수행.


```python
import sys

sys.stdin = open('input.txt','r')


N = int(sys.stdin.readline())
A = list(map(int,sys.stdin.readline().split()))

M = int(sys.stdin.readline())
B = list(map(int,sys.stdin.readline().split()))


A.sort()



# 사실 그냥 dictionary 이용하면 될 것 같은데

# 이전에는 숫자가 있는지 없는지만 탐색하면 되어서 상관 없었는데 이런 경우에는 어떡하지 ?
# B의 정수는 유일


dictionary = {}

for i in A :
    if i in dictionary :
        dictionary[i] += 1
    else :
        dictionary[i] = 1


u = list(dictionary.keys())

length = len(u)

def binary_search(given):

    answer = 0
    a = 0
    
    b = length -1

    while a <= b :

        point = (a+b)//2

        if u[point] == given :
            answer = dictionary[given]
            break
        elif u[point] < given :
            a = point +1
        elif u[point] > given :
            b = point -1

    return answer

for i in range(M) :
    
    print(binary_search(B[i]),end = ' ')
```
## 다른 사람들은 어떻게 풀었을까 ?

- 빠른 코드들은 Count로 미리 N을 딕셔너리로 만들고 
- M을 순회함.

```python
from sys import stdin
from collections import Counter
_ = stdin.readline()
N = stdin.readline().split()
_ = stdin.readline()
M = stdin.readline().split()

C = Counter(N)
print(' '.join(f'{C[m]}' if m in C else '0' for m in M))

```



## 이진탐색과 상/하한선
- [참고자료](https://codingmovie.tistory.com/42)

