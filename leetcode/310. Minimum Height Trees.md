## bfs를 통해서 각 node를 root로 선택했을때 height을 구했음.
## 해를 구하는 도중에 구해지는 후보보다 큰 경우 최소 길이 트리를 만족할 수 없을 것이므로 제외하는 것을 추가했음.
## 하지만 노드 약 400개 정도에서 시간 초과가 발생함.
## dfs

from collections import deque
class Solution:
    candidate = None
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:

        mat = [[0 for _ in range(n)] for _ in range(n)]

        for e in edges :
            mat[e[0]][e[1]] =1
            mat[e[1]][e[0]] =1
        def _inner(start):
            Q = deque([start])
            height = 0
            check = [0 for _ in range(n)]
            check[start] = 1
            
            while Q :
                length = len(Q)

                for _ in range(length):
                    this = Q.popleft()
                    
                    for index,j in enumerate(mat[this]):
                        if j == 1 and check[index] == 0 :
                            Q.append(index)
                            check[index] =1
                height +=1
                if self.candidate is not None and self.candidate < height :
                    return 
            return height
        out = []
        
        for i in range(n):
            can = (i,_inner(i))
            print(can)
            if self.candidate is None :
                self.candidate = can[1]
                out.append(can)
                continue
            
            if can[1] is not None and self.candidate >= can[1]:
                self.candidate = can[1]
                out.append(can)
        
        out.sort(key = lambda x : (x[1],x[0]))
        answer =[]
        val = None
        for o in out :
            if not answer :
                answer.append(o[0])
                val = o[1]
            else:
                if val < o[1] :
                    break
                else:
                    answer.append(o[0])
        


        
        return answer
